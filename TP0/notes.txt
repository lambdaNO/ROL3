###############################################################################
#################### Prise de notes distanciel RO #############################
###############################################################################

Lancement du programme depuis un terminal
> E131729J@I121V7pc11:~/L3/6S/RO/TP0$ julia
///////////////////////////////////////////////////////////////////////////////
Pour charger le contenu d’un fichier nomfichier.jl, il suffit de taper
julia > include(”nomfichier.jl”)
///////////////////////////////////////////////////////////////////////////////
Installation des packages depuis Julia :
      # JuMP : Julia for Mathematical optimization (JuMP is a domain-specific modeling language for mathematical optimization embedded in Julia.)

      julia> Pkg.add("JuMP")

      # GLPK : le solveur pour la programmation linéaire en variables entières

      julia> Pkg.add("GLPK")

      # GLPKMathProgInterface : Pour pouvoir utiliser GLPK avec JuMP

      julia> Pkg.add("GLPKMathProgInterface")

///////////////////////////////////////////////////////////////////////////////
Programme linéaire que l'on va modéliser avec JUMP

max z = 15 x1 + 60 x2 + 4 x3 + 20 x4
s.c.
20 x1 + 20 x2 + 10 x3 + 40 x4 ≤ 21
10 x1 + 30 x2 + 20 x3         ≤ 6
20 x1 + 40 x2 + 30 x3 + 10 x4 ≤ 14
x1 , x2 , x3 , x4 ≥ 0


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Le choix du solveur (pour GLPK) dépend du type des variables
Dès qu’une variable n’est pas continue, GLPKSolverLP() doit être remplacé par GLPKSolverMIP()
RAPPEL de moralité :
    Problème en variable discrète : GLPKSolverMIP()
    Problème en variable continue : GLPKSolverLP()



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Déclaration d'un modèle explicite :

Etape 0 : Déclaration des programmes que l'on va utiliser :

julia> using JuMP, GLPKMathProgInterface
INFO: Precompiling module JuMP.
INFO: Precompiling module GLPK.

Etape 1 : Déclaration d'un modèle vide - Spécification du solveur que l'on souhaite utiliser :

julia> m = Model(solver = GLPKSolverLP())
Feasibility problem with:
 * 0 linear constraints
 * 0 variables
Solver is GLPKInterfaceLP

Etape 2 : déclaration des variables de décisions associées à ce modèle
Attention : Il faut spécifier la non négativité des variables.
Structure : @variable(<nom_du_mdl>,<nom_de_la_var> >= 0)

julia> @variable(m,x1 >= 0)
x1

julia> @variable(m,x2 >= 0)
x2

julia> @variable(m,x2 >= 0)
WARNING: A variable or constraint named x2 is already attached to this model. If creating variables programmatically, use the anonymous variable syntax x = @variable(m, [1:N], ...).
x2

julia> @variable(m,x3 >= 0)
x3

julia> @variable(m,x4 >= 0)
x4

Etape 3 : déclaration de la fonction objectif (avec le type d'optimisation min/Max)
Attention : les variables de décisions doivent être déclarée à l'étape 2
Structure : @objective(<nom_du_mdl>, <type_opti>,<fct_var_décision>)
<type_opti> = {Min,Max}


julia> @objective(m, Max, 15x1 + 60x2 + 4x3 + 20x4)
15 x1 + 60 x2 + 4 x3 + 20 x4

Etape 4 : Déclaration des contraintes du modèle
Note : Nom de la contrainte facultatif mais potentiellement utile pour la suite.
Structure @constraint(<nom_du_mdl>, <nom_de_ctr>, <fct_contrainte>)
<op_fct_contrainte> = {<=, <, ==, >, >=}

julia> @constraint(m, Toxine1, 20x1 + 20x2 + 10x3 + 40x4 <= 21)
20 x1 + 20 x2 + 10 x3 + 40 x4 ≤ 21

julia> @constraint(m, Toxine2, 10x1 + 30x2 + 20x3 <= 6)
10 x1 + 30 x2 + 20 x3 ≤ 6

julia> @constraint(m, Toxine3, 20x1 + 40x2 + 30x3 + 10x4 <= 14)
20 x1 + 40 x2 + 30 x3 + 10 x4 ≤ 14


Etape 5 : Résolution du modèle
Structure : status = solve (<nom_du_mdl>)
Note : Résultats possibles
    :Optimal = Problème résolu à l’optimalité
    :Unbounded =  Problème non-borné
    :Infeasible = Problème impossible
    :Error = Sortie avec une erreur


julia> status = solve(m)
:Optimal

Pour obtenir le résultat de la fonction objectif résolue à l'optimalité : getobjectivevalue(<nom_du_mdl>)

julia> getobjectivevalue(m)
20.5


Pour obtenir le résultat des variables de décision pour le problème résolu à l'optimalité : getvalue(<nom_de_la_var>)
julia> getvalue(x1)
0.0

julia> getvalue(x2)
0.2

julia> getvalue(x3)
0.0

julia> getvalue(x4)
0.425

Vérification à la main au cas où 15*0 + 0.2*60 + 4*0.0 + 20*0.425 = 20.5

Remarque sur l'étape 2 :

Les variables sont par défaut continues et libres. Possibilité de spécifier des.bornes inférieures et/ou supérieures
pour une variable x :
  @variable(m,x)
  @variable(m, x >= lb)
  @variable(m, x <= ub)
  @variable(m, lb <= x <= ub)

  Pour définir les lower bound (lb) et upper bound (ub), il suffit d'écrire :

  julia> lb = 4
  4
  Et il les garde en mémoire - Par exemple si on rappe
  julia> lb
  4

Lors de la déclaration de variable, on peut rajouter un troisième paramètre pour spécifier le type de la variable :
Structure : @variable(<nom_du_mdl>,<nom_de_la_var> >= 0,<type_de_la_var>)
<type_de_la_var> = {Int, Bin}
  Int : pour une variable entière
  Bin : pour une variable binaire


Les symboles que l'on peut utiliser pour les comparaisons :
  <op_fct_contrainte> = {<=, <, ==, >, >=}
  - <= inférieur ou égal
  - < inférieur strict
  - == contrainte d'égalité [Attention]
  - > supérieur strict
  - >= supérieur ou égal

RAPPEL de moralité :
    Problème en variable discrète : GLPKSolverMIP()
    Problème en variable continue : GLPKSolverLP()

Petit plus : Déclaration d'une fonction d'affichage spécifique pour ce modèle - Mais là c'est inutile en fait
julia> function imprim(m,x1,x2,x3,x4)
       if status == :Optimal
           println("Problème résolu à l'optimalité")

           println("z = ",getobjectivevalue(m)) # affichage de la valeur optimale

           println("x1 = ",getvalue(x1))
           println("x2 = ",getvalue(x2))
           println("x3 = ",getvalue(x3))
           println("x4 = ",getvalue(x4)) # affichage des valeurs des variables

       elseif status == :Unbounded
           println("Problème non-borné")

       elseif status == :Infeasible
           println("Problème impossible")
       end
       end
imprim (generic function with 1 method)
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Moralité de fin :
julia> using JuMP, GLPKMathProgInterface

julia> m = Model(solver = GLPKSolverLP())
Feasibility problem with:
 * 0 linear constraints
 * 0 variables
Solver is GLPKInterfaceLP
julia> @variable(m,x1 >= 0)
x1
julia> @variable(m,x2 >= 0)
x2
julia> @variable(m,x3 >= 0)
x3
julia> @variable(m,x4 >= 0)
x4
julia> @objective(m, Max, 15x1 + 60x2 + 4x3 + 20x4)
15 x1 + 60 x2 + 4 x3 + 20 x4
julia> @constraint(m, Toxine1, 20x1 + 20x2 + 10x3 + 40x4 <=21)
20 x1 + 20 x2 + 10 x3 + 40 x4 ≤ 21
julia> @constraint(m, Toxine2, 10x1 + 30x2 + 20x3 <= 6)
10 x1 + 30 x2 + 20 x3 ≤ 6
julia> @constraint(m, Toxine3, 20x1 + 40x2 + 30x3 + 10x4 <= 14)
20 x1 + 40 x2 + 30 x3 + 10 x4 ≤ 14
julia> status = solve(m)
:Optimal
julia> imprim(m,x1,x2,x3,x4)
Problème résolu à l'optimalité
z = 20.5
x1 = 0.0
x2 = 0.2
x3 = 0.0
x4 = 0.425

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Motivation pour la création d'un  modèle implicite :

Dans le cas où l'on a plusieurs instances numériques : il ne faut pas écrire de modèle explicite pour résoudre chaque instance.
Nécessité de séparer les éléments le modèle (Vecteurs, Matrices, ...)
=> On parle de modèle implicite.

On repart d'un modèle vide :

julia> m = Model(solver = GLPKSolverLP())
Feasibility problem with:
 * 0 linear constraints
 * 0 variables
Solver is GLPKInterfaceLP

Déclaration d'un tableau de variable :

julia> @variable(m,x[1:4] >= 0)
4-element Array{JuMP.Variable,1}:
 x[1]
 x[2]
 x[3]
 x[4]

Les tableaux de variables reposent sur une syntaxe différente des tableaux en Julia On ne spécifie pas la taille mais un ensemble d’indices

Les indices peuvent être négatifs :
    julia> @variable(m,y[-3:3] >= 0)
    y[i] ≥ 0 ∀ i ∈ {-3,-2,…,2,3}

Les indices peuvent ne pas être entiers :
  julia> @variable(m,ville["C","B","A"] >= 0)
  ville[i,j,k] ≥ 0 ∀ i ∈ {C}, j ∈ {B}, k ∈ {A}

  julia> m
  Feasibility problem with:
  * 0 linear constraints
  * 1 variable
  Solver is GLPKInterfaceLP

  julia> ville
  ville[i,j,k] ≥ 0 ∀ i ∈ {C}, j ∈ {B}, k ∈ {A}

/////////////
  julia> @variable(m,ville["Nantes","Vertou","Rezé"] >= 0)
  WARNING: A variable or constraint named ville is already attached to this model. If creating variables programmatically, use the anonymous variable syntax x = @variable(m, [1:N], ...).
  ville[i,j,k] ≥ 0 ∀ i ∈ {N,a,…,e,s}, j ∈ {V,e,…,o,u}, k ∈ {R,e,z,é}
/////////////
